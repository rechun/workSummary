## 实现一个 new

```js
function New(func) {
  const res = {};
  if (func.prototype !== null) {
    res.__proto__ = func.prototype;
  }
  const ret = func.apply(res, Array.prototype.slice.call(arguments, 1));
  if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
    return ret;
  }
  return res;
}
```

## 实现一个 instanceof 方法

```js
function instanceOf(left, right) {
  let proto = left.__proto__;
  let prototype = right.prototype;
  while (true) {
    if (proto === null) return false;
    if (proto === prototype) return true;
    proto = proto.__proto__;
  }
}
```

## 写一个 JSON.stringify

```js
function jsonStringify(obj) {
  let type = typeof obj;
  if (type !== "object") {
    if (/string|undefined|function/.test(type)) {
      obj = '"' + obj + '"';
    }
    return String(obj);
  } else {
    let json = [];
    let arr = Array.isArray(obj);
    for (let k in obj) {
      let v = obj[k];
      let type = typeof v;
      if (/string|undefined|function/.test(type)) {
        v = '"' + v + '"';
      } else if (type === "object") {
        v = jsonStringify(v);
      }
      json.push((arr ? "" : '"' + k + '":') + String(v));
    }
    return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
  }
}
```

## 写一个 JSON.parse

```js
var jsonStr = '{ "age": 20, "name": "jack" }';
var json = new Function("return " + jsonStr)();
```

## 写一个 LRU 缓存函数

```js
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return -1;

    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else {
      if (this.cache.size === this.capacity) {
        // 获取到Map中第一个数据的key值，即最近最少访问的key，删之
        const delKey = this.cache.keys().next().value;
        this.cache.delete(delKey);
      }
    }
    this.cache.set(key, value);
  }
}
```

## 写个防抖函数

```js
// 防抖动函数
function debounce(fn, wait = 50, immediate) {
  let timer;
  return function () {
    if (immediate) {
      fn.apply(this, arguments);
    }
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, wait);
  };
}
```

## 写个节流函数

```js
function throttle(fn, wait) {
	let prev = new Date();
	return function() {
	  const args = arguments;
		const now = new Date();
		if (now - prev > wait) {
			fn.apply(this, args);
			prev = new Date();
		}
	}

```

## 实现一个 compose 函数
```js
function compose(...args) {
  
}
```
## 实现 DOM 字符串转虚拟 DOM 对象

## 实现一个 Promise.all

```js
Promise.all = function (iterator) {
  let count = 0; //用于计数，当等于len时就resolve
  let len = iterator.length;
  let res = []; //用于存放结果
  return new Promise((resolve, reject) => {
    for (let i in iterator) {
      Promise.resolve(iterator[i]) //先转化为Promise对象
        .then((data) => {
          res[i] = data;
          if (++count === len) {
            resolve(res);
          }
        })
        .catch((e) => {
          reject(e);
        });
    }
  });
};
```

## 实现 promise.race

```js
Promise.race = function (iterators) {
  return new Promise((resolve, reject) => {
    for (const p of iterators) {
      Promise.resolve(p)
        .then((res) => {
          resolve(res);
        })
        .catch((e) => {
          reject(e);
        });
    }
  });
};
```

## 实现一个深拷贝

```js
function deepCopy(obj) {
  //判断是否是简单数据类型，
  if (typeof obj == "object") {
    //复杂数据类型
    var result = obj.constructor == Array ? [] : {};
    for (let i in obj) {
      result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i];
    }
  } else {
    //简单数据类型 直接 == 赋值
    var result = obj;
  }
  return result;
}
```

## 实现一个二叉搜索树转链表的方法

```js
var treeToDoublyList = function (root) {
  if (!root) {
    return;
  }
  //非递归中序遍历
  const stack = [];
  var current = root;
  var pre = null;
  var head = null;
  while (stack.length > 0 || current) {
    while (current) {
      stack.push(current);
      current = current.left;
    }
    current = stack.pop();
    //左子树的左后一个结点
    if (!pre) {
      head = current;
    } else {
      pre.right = current;
    }
    current.left = pre;
    pre = current;
    current = current.right;
  }

  //循环链表
  head.left = pre;
  pre.right = head;
  return head;
};
```

## 怎么判断是否为数组？

```js
Array.isArray();
```

## 数组有 10 万个数据，取第一个和取第 10 万个的耗时多久？

O(1)

## 实现一个 bind 函数

```js
Function.prototype.bind2 = function (content) {
  if (typeof this != "function") {
    throw Error("not a function");
  }
  // 若没问参数类型则从这开始写
  let fn = this;
  let args = [...arguments].slice(1);

  let resFn = function () {
    return fn.apply(
      this instanceof resFn ? this : content,
      args.concat(...arguments)
    );
  };
  function tmp() {}
  tmp.prototype = this.prototype;
  resFn.prototype = new tmp();

  return resFn;
};
```

## 实现 add(1) (2) (3) | 函数柯里化

```js
function toCurry(func, ...args) {
    // ↑需要柯里化的函数作为参数
    // ↑也可以有初始参数传入
    // ↑缓存在args中
​
    return function () {
        // 合并上一次缓存的参数和本次传入的参数
        args = [...args,...arguments];
        // 判断参数数量是否足够
        if (args.length < func.length) {
            // 如果不够，继续递归
            // 注意，这里每一次递归都会形成新的闭包
            // 保证柯里化函数每一步调用都是独立的，互不影响
            return toCurry(func, ...args);
        } else
           // 如果参数满足数量，执行函数并返回结果
            return func.apply(null, args);
        }
    }
}

```

## 大数相加

```js
function add(a, b) {
  //取两个数字的最大长度
  let maxLength = Math.max(a.length, b.length);
  //用0去补齐长度
  a = a.padStart(maxLength, 0); //"0009007199254740991"
  b = b.padStart(maxLength, 0); //"1234567899999999999"
  //定义加法过程中需要用到的变量
  let t = 0;
  let f = 0; //"进位"
  let sum = "";
  for (let i = maxLength - 1; i >= 0; i--) {
    t = parseInt(a[i]) + parseInt(b[i]) + f;
    f = Math.floor(t / 10);
    sum = (t % 10) + sum;
  }
  if (f == 1) {
    sum = "1" + sum;
  }
  return sum;
}
```

## 拍平数组 | flatten （递归、栈）

```js
// 递归
function flat(arr) {
  let arrResult = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      arrResult = arrResult.concat(arguments.callee(item)); // 递归
      // 或者用扩展运算符
      // arrResult.push(...arguments.callee(item));
    } else {
      arrResult.push(item);
    }
  });
  return arrResult;
}
```

```js
// 栈思想
function flat(arr) {
  const result = [];
  const stack = [].concat(arr); // 将数组元素拷贝至栈，直接赋值会改变原数组
  //如果栈不为空，则循环遍历
  while (stack.length !== 0) {
    const val = stack.pop();
    if (Array.isArray(val)) {
      stack.push(...val); //如果是数组再次入栈，并且展开了一层
    } else {
      result.unshift(val); //如果不是数组就将其取出来放入结果数组中
    }
  }
  return result;
}
```

## 字符串翻转

```js
const reverse = ([h, ...t]) => (h ? reverse(t) + h : "");
```

## 数组去重

```js
function unique(arr) {
  return Array.from(new Set(arr));
}
```

```js
function unique(arr) {
  return arr.filter(function (item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
```

## 千位分隔符

```js
const reg = /(?!^)(?=(\d{3})+$)/g;

function kilofy(n) {
  return String(n).replace(reg, ",");
}
```

```js
function kilofy(n) {
  return n.toLocaleString("zh-CN");
}
```

## twoSum

```js
function twoSum(target) {
  // 双指针法
  var n = numbers.length;
  var lo = 0;
  hi = n - 1;
  var comp;
  while (lo <= hi) {
    comp = target - (numbers[lo] + numbers[hi]);
    if (comp == 0) {
      return [lo + 1, hi + 1];
    } else if (comp > 0) {
      lo = lo + 1;
    } else {
      hi = hi - 1;
    }
  }
  return [-1, -1];
}
```

## 判断素数

```js
function isPrime(num) {
  if (num === 2 || num === 3) {
    return true;
  }
  if (num % 2 === 0) {
    return false;
  }
  let divisor = 3,
    limit = Math.sqrt(num);
  while (limit >= divisor) {
    if (num % divisor === 0) {
      return false;
    } else {
      divisor += 2;
    }
  }
  return true; //结束就返回true，否则在while中就返回false
}
```

## 字符串解析

## 合并区间

> 输入: [[1,3],[2,6],[8,10],[15,18]]

> 输出: [[1,6],[8,10],[15,18]]

> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

```js
var merge = function (intervals) {
  if (!intervals || !intervals.length) return [];
  intervals.sort((a, b) => a[0] - b[0]);
  let ans = [intervals[0]];
  for (let i = 1; i < intervals.length; i++) {
    if (ans[ans.length - 1][1] >= intervals[i][0]) {
      ans[ans.length - 1][1] = Math.max(
        ans[ans.length - 1][1],
        intervals[i][1]
      );
    } else {
      ans.push(intervals[i]);
    }
  }
  return ans;
};
```

## 实现 call

```js
Function.prototype.call2 = function (content = window) {
  content.fn = this;
  let args = [...arguments].slice(1);
  let result = content.fn(...args);
  delete content.fn;
  return result;
};
let foo = {
  value: 1,
};
function bar(name, age) {
  console.log(name);
  console.log(age);
  console.log(this.value);
}
bar.call2(foo, "black", "18"); // black 18 1
```

## 实现 apply

```js
Function.prototype.apply2 = function (context = window) {
  context.fn = this;
  let result;
  // 判断是否有第二个参数
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

## 最后一个单词的长度

```js
var lengthOfLastWord = function (s) {
  let num = 0;
  var len = s.length - 1;
  while (len >= 0 && s[len] == " ") len--; //去除末尾空格
  for (let i = len; i >= 0; i--) {
    //从末尾开始向前查找，直到等于空格 return
    if (s.charAt(i) == " ") return num;
    num++;
  }
  return num;
};
```

## 合并两个有序数组

```js
/**
 * --- 问题描述 ---
 *
 * 实现一个 merge 函数，实现有序数组合并
 *
 * --- 测试用例 ---
 *
 * 输入：a = [1,3,5]
 *     b = [2,4,6]
 * 输出：[1,2,3,4,5,6]
 */

var merge = function (nums1, m, nums2, n) {
  let idx = m + n - 1;
  let i = m - 1;
  let j = n - 1;
  while (i >= 0 && j >= 0) {
    nums1[idx--] = nums1[i] < nums2[j] ? nums2[j--] : nums1[i--];
  }
  for (let k = 0; k <= j; k++) {
    nums1[k] = nums2[k];
  }
};
```

## 整数反转

```js
const reverseNum = (num) => {
  if (num >= 0) {
    const numStr = String(num); //将数字转成字符串，方便转成数组
    return Number(numStr.split("").reverse().join("")); //详见注释1
  } else {
    const numStr = String(num); //将数字转成字符串，方便转成数组
    return -numStr.slice(1).split("").reverse().join(""); //详见注释2
  }
};
```

## 有效的括号

```js
var isValid = function (s) {
  while (s.length) {
    var temp = s;
    s = s.replace("()", "");
    s = s.replace("[]", "");
    s = s.replace("{}", "");
    if (s == temp) return false;
  }
  return true;
};
```

## 最长回文字串

```js
/**

* @param  {string}  s

* @return  {string}

*/

const longestPalindrome1 = (s) => {
  if (!s || !s.length) {
    return "";
  }

  let result = "";

  for (let i = 0; i < s.length; i++) {
    const odd = expandCenter(s, i, i);

    const even = expandCenter(s, i, i + 1);

    if (odd.length > result.length) {
      result = odd;
    }

    if (even.length > result.length) {
      result = even;
    }
  }

  return result;
};

/**
    
    * @param  {string}  s
    
    * @return  {string}
    
    */

const setTarget = (s) => {
  if (!s) {
    return "";
  }

  if (s.length === 0) {
    return "^$";
  }

  let res = "^";

  for (let i = 0, len = s.length; i < len; ++i) {
    res = res + "#" + s.charAt(i);
  }

  res += "#$";

  return res;
};

/**
    
    * @param  {string}  s
    
    * @return  {string}
    
    */

const longestPalindrome2 = (s) => {
  let str = setTarget(s);

  let len = str.length;

  let arr = new Array(len);

  let C = 0; // 右边界最大的回文子串的中心

  let R = 0; // 子串右边界

  for (let i = 1; i < len - 1; ++i) {
    let j = 2 * C - i;

    if (R > i) {
      arr[i] = Math.min(R - i, arr[j]); // 右边界处理
    } else {
      arr[i] = 0;
    }

    // 遇到上述三种特殊情况时，使用中心拓展法

    while (str[i + 1 + arr[i]] === str[i - 1 - arr[i]]) {
      arr[i]++;
    }

    // 判断是否需要更新R的值

    if (i + arr[i] + R) {
      C = i;

      R = i + arr[i];
    }
  }

  let maxLen = 0; // 最大长度

  let index = 0; // 中心下标

  for (let i = 1; i < len - 1; ++i) {
    if (arr[i] > maxLen) {
      maxLen = arr[i];

      index = i;
    }
  }

  let start = (index - maxLen) / 2;

  return s.substring(start, start + maxLen);
};
```

## 原型实现继承

```js
function Parent(name) {
  this.name = name;
}
Parent.prototype.sayName = function () {
  console.log("parent name:", this.name);
};
function Child(name, parentName) {
  Parent.call(this, parentName);
  this.name = name;
}
function create(proto) {
  function F() {}
  F.prototype = proto;
  return new F();
}
Child.prototype = create(Parent.prototype);
Child.prototype.sayName = function () {
  console.log("child name:", this.name);
};
Child.prototype.constructor = Child;

var parent = new Parent("father");
parent.sayName(); // parent name: father

var child = new Child("son", "father");
```

## 实现 EventEmitter

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }
  on(type, listener, isUnshift) {
    // 因为其他的类可能继承自EventEmitter，子类的events可能为空，保证子类必须存在此实例属性
    if (!this.events) {
      this.events = {};
    }
    if (this.events[type]) {
      if (isUnshift) {
        this.events[type].unshift(listener);
      } else {
        this.events[type].push(listener);
      }
    } else {
      this.events[type] = [listener];
    }

    if (type !== "newListener") {
      // node的EventEmitter模块自带的特殊事件，该事件在添加新事件监听器的时候触发
      this.emit("newListener", type);
    }
  }
  emit(type, ...args) {
    if (this.events[type]) {
      this.events[type].forEach((fn) => fn.call(this, ...args));
    }
  }
  // 只绑定一次，然后解绑
  once(type, listener) {
    const me = this;
    function oneTime(...args) {
      listener.call(this, ...args);
      me.off(type, oneTime);
    }
    me.on(type, oneTime);
  }
  off(type, listener) {
    if (this.events[type]) {
      const index = this.events[type].indexOf(listener);
      this.events[type].splice(index, 1);
    }
  }
}
```

## 数组三等分

```js
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var canThreePartsEqualSum = function (arr) {
  let sum = arr.reduce((a, b) => a + b);
  let num = 3;
  let temp = 0;
  for (let a of arr) {
    temp += a;
    if (temp === sum / 3) num--, (temp = 0);
  }
  return num <= 0;
};
```

## x 的平方根

```js
function sqrtNewton(n) {
  if (n < 0) return NaN;
  if (n === 0 || n === 1) return n;
  var val = n,
    last;
  do {
    console.log(val, last);
    last = val;
    val = (val + n / val) / 2;
  } while (
    // 2018-04-25 22:08 更新
    // 使用Number.EPSILON表示能够接受的最小误差范围
    Math.abs(val - last) >= Number.EPSILON
  );
  return val;
}
```

## 删除排序后数组中的重复

## 移动 0

```js
//输入: [0,1,0,3,12]
//输出: [1,3,12,0,0]
var moveZeroes = function (nums) {
  var start = 0; //数组头
  var end = nums.length - 1; //数组尾
  while (start < end) {
    if (nums[start] === 0) {
      //如果数组头的元素为0
      nums.splice(start, 1); //删除这个0元素
      nums.push(0); //并在数组尾部推入0
      end--; //因为数组尾部被0占入，所以end减1
      start--; //因为头部0元素被删除，所以start减1
    }
    start++;
  }
};
```

## 快乐数

```js
/**
 * 「快乐数」定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
*/
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function (n) {
  while (
    (n = n
      .toString()
      .split("")
      .reduce((p, v) => p + v * v, 0))
  ) {
    if (n === 1) return true;
    if (n === 4) return false;
  }
};
```

## promise limit

## 异步串行，异步并行

```js
// 异步并行
class Executor {
  constructor() {
    this.tasks = [];
    this.tasksPromise = [];
  }
  register(name, fn) {
    this.tasks.push(fn);
  }
  execute(...args) {
    let finalCall = args.pop(),
      index = 0,
      done = () => {
        index++;
        if (index == this.tasks.length) {
          finalCall();
        }
      };
    this.tasks.forEach((fn) => fn(...args, done));
  }

  registerPromise(name, fn) {
    this.tasksPromise.push(fn);
  }
  executePromise(...args) {
    this.tasksPromise = this.tasksPromise.map((fn) => fn(...args));
    return Promise.all(this.tasksPromise);
  }
}

let excutor = new Executor();
excutor.register("TaskA", function (data, cb) {
  setTimeout(() => {
    console.log(data, "task A....");
    cb();
  }, 1000);
});
excutor.register("TaskB", function (data, cb) {
  setTimeout(() => {
    console.log(data, "task B....");
    cb();
  }, 1000);
});
excutor.execute("普通异步并行......", function () {
  console.log("普通异步并行 end----");
});
excutor.registerPromise("PromiseA", function (data) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(data, "Promise A....");
      resolve(data);
    }, 3000);
  });
});
excutor.registerPromise("PromiseB", function (data) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(data, "Promise B....");
      resolve(data);
    }, 3000);
  });
});
excutor.executePromise("Promise异步并行......").then(function () {
  console.log("Promise end------");
});

// 异步串行
class Executor {
  constructor() {
    this.tasks = [];
    this.tasksPromise = [];
  }
  register(name, fn) {
    this.tasks.push(fn);
  }
  execute(...args) {
    let index = 0;
    let finalCallback = args.pop();

    let next = (data) => {
      if (index == this.tasks.length) return finalCallback(data);
      let task = this.tasks[index];

      if (index == 0) {
        task(...args, next);
      } else {
        task(data, next);
      }
      index++;
    };
    next(...args);
  }

  registerPromise(name, fn) {
    this.tasksPromise.push(fn);
  }
  executePromise(...args) {
    let index = 0;
    let p;
    let next = (data) => {
      p = this.tasksPromise[index++](data);
      if (index == this.tasksPromise.length) {
        return p;
      } else {
        return p.then((d) => next(d));
      }
    };
    return next(...args);
  }
}

let excutor = new Executor();
excutor.register("TaskA", function (data, cb) {
  setTimeout(() => {
    console.log(data);
    cb("task A....");
  }, 1000);
});
excutor.register("TaskB", function (data, cb) {
  setTimeout(() => {
    console.log(data);
    cb("task B....");
  }, 1000);
});
excutor.execute("普通异步串行......", function (data) {
  console.log(data);
  console.log("普通异步串行end---");
});
excutor.registerPromise("PromiseA", function (data) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(data);
      resolve("Promise A....");
    }, 3000);
  });
});
excutor.registerPromise("PromiseB", function (data) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(data);
      resolve("Promise B....");
    }, 3000);
  });
});
excutor.executePromise("Promise异步串行......").then(function (data) {
  console.log(data);
  console.log("Promise异步串行 end------");
});
```

## 实现一个缓存函数

```js
const memorize = function (fn) {
  const cache = {}; // 存储缓存数据的对象
  return function (...args) {
    // 这里用到数组的扩展运算符
    const _args = JSON.stringify(args); // 将参数作为cache的key
    return cache[_args] || (cache[_args] = fn.apply(fn, args)); // 如果已经缓存过，直接取值。否则重新计算并且缓存
  };
};
const add = function (a, b) {
  console.log("开始缓存");
  return a + b;
};

const adder = memorize(add);
```
