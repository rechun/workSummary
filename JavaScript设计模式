OOP（Object-oriented programming） 面向对象编程

是一种程序设计范型，它将对象作为程序的基本单元，将程序和数据封装其中,
以提高程序的重用性/灵活性/扩展性.


================================ 1.3  将对象收编变量 ==============================

var CheckObject = {
  checkName:function(){
    //验证姓名
  },
  checkEmail:function(){
  //验证邮箱
  },
  checkPassword:function(){
  //验证密码
  }
}
将所有的函数作为checkObject对象的方法，这样我们就只有一个对象。

================================ 1.4  对象的另一种形式==============================


var checkObject = function (){};
checkObject.checkName = function(){
  //验证姓名
}
checkObject.checkEmail = function(){
  //验证邮箱
}
checkObject.checkPassword = function(){
  //验证密码
}
这个对象在用new 关键字创建新的对象是,新创建的对象是不能继承这些方法的.

================================ 1.5 ==============================

var checkObject = function(){
  return {
      checkName :function(){
        //验证姓名
      },
      checkEmail:function(){
        //验证邮箱
      },
      checkPssword:function(){
        //验证密码
      }
    }
}

每次调用这个函数时都返回一个新对象.

================================ 1.6    类也可以==============================
  
  var checkObject = function (){
    this.checkName = function(){
      //验证姓名
    },
    this.checkEmail = function(){
      //验证邮箱
    },
    this.checkPassword = function(){
      //验证密码
    }
  }
  var a = new checkObject();
  a.checkEmail();
  
  
================================ 1.7 一个检测类 ==============================

 我们把所有的方法放在函数内部,通过this定义。
 每一次通过new 关键字创建新对象的时候,新创建的对象都会对类的this上的属性进行复制.
 
 var checkObject = function(){}
 checkObject.prototype.checkName = function(){
    //验证姓名
 }
  checkObject.prototype.checkEmail = function(){
    //验证邮箱
  }
   checkObject.prototype.checkPassword = fuction(){
      //验证密码
   }
   
   
   var checkObject = function(){}
   checkObject.prototype = function(){
      checkName = function(){
        //验证姓名
      }
      checkEmail = function(){
        //验证邮箱
     }
      checkPassword = function(){
        //验证密码
     }
   }
   
   这两种方法都可以
   
   这样创建对象实例的时候,创建出来的对象所拥有的方法就都是一个了.
   因为他们都要依赖protptype原型,依次寻找,
   他们都绑定在checkObject对象类的原型上.
   
   
   ================================ 1.8 方法还可以这样用 ==============================
 
    在js中this指向的就是当前对象,所以你可以将它返回.
    
    
    var checkObject = function(){
      checkName :function(){
        //验证姓名
        return this
      }
      checkEmail :function(){
        //验证姓名
        return this
      }
      checkPassword :function(){
        //验证邮箱
        return this
      }
    }
    
    ================================ 1.9 函数的祖先 ==============================
  
  你想给每一个函数都添加一个检测邮箱的方法
  Function.prototype.checkEmail = function(){
    //验证邮箱
  }
  
  
  如果你喜欢函数形式,name你可以这么做
  var f = function(){ };
  f.checkEmail();
  
  如果你喜欢类的形式可以这么做
  var f = new Function();
  f.checkEmail();
  
 这样污染了原生对象Function,所以别人创建的函数也会被你创建的函数所污染,造成不必要的开销.
 
 你可以抽象出一个统一添加方法的功能方法
 Function.prototype.addMethod = function(name,fn){
  this[name] = fn;
 }
 
 当你想添加邮箱验证和姓名验证方法
 
 var methods = function(){ };
 或者
 var methods = new Function();
 methods.addMethod('checkName',function(){
    //验证姓名
 })
 methods.addMethod('checkEmail',function(){
    //验证邮箱
 })
 methods.checkName();
 methods.checkEmail();
 
 
 ================================ 1.10 可以链式添加么 ==============================
 如果我想链式添加方法,在addMethod中将this返回
 Function.prototype.addMethod = function(name,fn){
    this[name] = fn;
    return this;
 }    
 methods.addMethod('checkName',function(){
    //验证姓名
    return this;
 }).addMethod('checkEmail',function(){
    //验证邮箱
    return this;
 });
 
 methods.checkName().checkEmail();
 
 
  ================================ 1.11 换一种方式使用方法 ==============================
 
 Function.prototype.addMethod = function(name,fn){
  return.prototype[name] = fn;
 }
 
var Methods = function(){};
methods.addMethod('checkName',function(){
    //验证姓名
}).addMethod('checkEmail',function(){
    //验证邮箱
})
var m = new Methods();
m.checkEmail();


